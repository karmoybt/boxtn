A FUTUTRO 
WOD Management:

wods - Historial de entrenamientos diarios
movimientos - Base de movimientos CrossFit (peso, repeticiones, tiempo)
registros_wod - Rendimiento de usuarios en cada WOD
Tracking de Rendimiento:

maximos - PRs personales (1RM, etc.)
estadisticas - Progresos, asistencias, WODs completados
metas - Objetivos personales de usuarios

Clases y Entrenamiento:

nivel_clase - Niveles de dificultad (Fundamentals, RX, etc.)
asignaciones_coach - Horarios y disponibilidad coaches
evaluaciones - Skills assessments para movimientos
notas_usuario - Comentarios mÃ©dicos/restricciones
Seguimiento Avanzado:

cargas_entrenamiento - PeriodizaciÃ³n, volumen, intensidad
injuries - Lesiones y estado fÃ­sico
body_composition - Mediciones corporales
comentarios_coach - Feedback individual
GestiÃ³n Interna:

inventario - Material del box (kettlebells, etc.)
mantenimiento - Estado del equipamiento
encuestas - Feedback sobre clases/movimientos
Notificaciones:

notificaciones - Recordatorios, anuncios, cambios
preferencias_notif - ConfiguraciÃ³n por usuario


Perfecto, tienes una base sÃ³lida. Lo que necesitas ahora es **alinear tu lÃ³gica de permisos en TypeScript con tu modelo de base de datos**, sin depender de constantes en el cÃ³digo para la lÃ³gica de autorizaciÃ³n. AquÃ­ va el **plan estratÃ©gico** para migrar tu sistema de permisos a base de datos, manteniendo flexibilidad, mantenibilidad y escalabilidad:

---

### ğŸ”‘ **Objetivo Central**
**Reemplazar las constantes de permisos en `permissions.ts` por una resoluciÃ³n dinÃ¡mica desde la base de datos**, sin perder seguridad, claridad ni rendimiento.

---

### âœ… **Paso 1: Normaliza los permisos en BBDD (ya casi lo tienes)**
Actualmente defines permisos como strings descriptivos (`'crear_lead'`, `'reservar'`, etc.).  
**Mejora:** AlinÃ©alos **exactamente** a los nombres que usas en `permissions.ts`, como `'leads:create'`.

â¡ï¸ **AcciÃ³n:** Actualiza la tabla `permisos` con los nombres **en formato canonizado**:
```sql
UPDATE permisos SET nombre = 'leads:create' WHERE nombre = 'crear_lead';
-- ... y asÃ­ con todos
```
Esto asegura que **el string del permiso sea el mismo en BBDD y en backend** â†’ evitas bugs por desincronizaciÃ³n.

---

### âœ… **Paso 2: Carga los permisos del rol una sola vez por sesiÃ³n (caching)**
No querrÃ¡s hacer una query por cada llamada a `assertPermission`.

â¡ï¸ **AcciÃ³n:** Al iniciar sesiÃ³n o resolver el usuario, carga **todos los permisos de su rol** desde:
```sql
SELECT p.nombre
FROM roles_permisos rp
JOIN permisos p ON rp.permiso_id = p.id
WHERE rp.rol_id = ?;
```
Guarda ese array en contexto (ej: `req.user.permissions` o en tu objeto de sesiÃ³n).  
Luego `assertPermission(userId, 'leads:create')` se convierte en una **comparaciÃ³n en memoria**, no en BBDD.

> ğŸ’¡ Esto es clave para rendimiento y evitar llamadas repetidas.

---

### âœ… **Paso 3: Reemplaza las constantes en TS por validaciÃ³n contra el array cargado**
Elimina (o convierte en solo tipo) las constantes como `LEAD_PERMISSIONS`.  
Tu funciÃ³n `assertPermission` ya no necesita saber quÃ© permisos existen: solo verifica si el string dado estÃ¡ en el array del rol.

â¡ï¸ **Resultado:** Ya no necesitas mantener sincronizaciÃ³n manual entre TS y BBDD mÃ¡s que en **los nombres de los permisos** (que ahora son los mismos).

---

### âœ… **Paso 4: Gestiona asignaciones de permisos vÃ­a interfaz o scripts, no hardcode**
Tienes inserts manuales en SQL. Para mantenimiento a largo plazo:

- Crea un **panel de administraciÃ³n simple** (solo para admin) que permita:
  - Ver roles
  - Asignar/desasignar permisos a roles
- O, al menos, **un script de inicializaciÃ³n** en TS/SQL que se ejecute al migrar, **con los mismos nombres que usas en el frontend/backend**.

Esto evita que un typo en SQL rompa la app.

---

### âœ… **Paso 5: Asegura consistencia con migraciones y tests**
Cada vez que agregues un nuevo permiso:
1. Agregas el string en BBDD (`INSERT INTO permisos`)
2. Asignas a roles segÃºn reglas de negocio
3. **No tocas** `permissions.ts` (o lo usas solo como referencia de tipos)
4. **Testea** que `assertPermission` funciona para cada rol

---

### ğŸš« **Errores comunes que debes evitar**
- **Hardcodear IDs de roles o permisos** en la app â†’ siempre usa nombres (`'admin'`, `'leads:create'`).
- **No cachear permisos por sesiÃ³n** â†’ matarÃ¡s la BBDD con queries redundantes.
- **Desalinear nombres entre TS y BBDD** â†’ la fuente de bugs mÃ¡s silenciosos.
- **Dar permisos a usuarios individuales** (a menos que sea necesario) â†’ mantÃ©n la lÃ³gica en **roles**, no en usuarios.

---

### ğŸ”® **Bonus: Escalabilidad futura**
Si algÃºn dÃ­a necesitas permisos por usuario (no solo por rol), podrÃ­as aÃ±adir una tabla `usuarios_permisos` que **se sume** a los del rol (sin reemplazarlos). Tu `assertPermission` seguirÃ­a funcionando igual: solo cambia cÃ³mo armas el array de permisos del usuario.

---

### âœ… **Resumen del flujo ideal**
1. Usuario inicia sesiÃ³n â†’ obtienes su `rol_id`.
2. Cargas todos los `permisos.nombre` asociados a ese rol.
3. Guardas esos permisos en contexto de usuario.
4. En cada endpoint, `assertPermission(userId, 'recurso:accion')` verifica si ese string estÃ¡ en el array.
5. Todo el control de acceso vive en BBDD â†’ modificable sin deploy.

