todo 
Perfecto, Javi. Vamos a refactorizar todo siguiendo buenas prÃ¡cticas, con el cÃ³digo listo para usar en tu estructura actual.

---

## ğŸ“ Estructura propuesta

```
server/
â”œâ”€â”€ constants/
â”‚   â””â”€â”€ permissions.ts
â”œâ”€â”€ services/
â”‚   â””â”€â”€ leads.ts          â† lÃ³gica central (reemplaza tu composable)
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ db/
â”‚   â”‚   â””â”€â”€ client.ts
â”‚   â”œâ”€â”€ getRoles.ts
â”‚   â”œâ”€â”€ getUserRole.ts
â”‚   â””â”€â”€ assertPermission.ts   â† helper de permisos
â””â”€â”€ api/
    â””â”€â”€ leads/
        â”œâ”€â”€ index.get.ts
        â”œâ”€â”€ index.post.ts
        â”œâ”€â”€ [id].patch.ts
        â””â”€â”€ [id].delete.ts
```

---

### 1. âœ… Constantes de permisos  
**`server/constants/permissions.ts`**

```ts
export const LEAD_PERMISSIONS = {
  READ: 'leads:read',
  CREATE: 'leads:create',
  UPDATE: 'leads:update',
  DELETE: 'leads:delete'
} as const;

export type LeadPermission = typeof LEAD_PERMISSIONS[keyof typeof LEAD_PERMISSIONS];
```

---

### 2. âœ… Helper para verificar permisos  
**`server/utils/assertPermission.ts`**

```ts
import { getUserRole } from './getUserRole';
import { getPermissionsByRole } from './getRoles';
import { LEAD_PERMISSIONS } from '../constants/permissions';

export async function assertPermission(
  userId: string,
  requiredPermission: keyof typeof LEAD_PERMISSIONS
): Promise<void> {
  const roleId = await getUserRole(userId);
  if (roleId === null) throw new Error('Usuario no encontrado.');

  const permissions = await getPermissionsByRole(roleId);
  if (!permissions.includes(LEAD_PERMISSIONS[requiredPermission])) {
    throw new Error('Permiso denegado.');
  }
}
```

---

### 3. âœ… Servicio central de leads  
**`server/services/leads.ts`**

```ts
import client from '../utils/db/client';
import { auditLog } from '../composables/log/useAuditLog'; // asumiendo que esto corre en server
import { assertPermission } from '../utils/assertPermission';
import { LEAD_PERMISSIONS } from '../constants/permissions';

// â”€â”€â”€ TIPOS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export type LeadFilters = Partial<Record<'nombre' | 'email' | 'estado_id', string | number>>;
export type LeadData = {
  id: string;
  nombre: string;
  email?: string | null;
  telefono?: string | null;
  estado_id: number;
};
export type LeadUpdateData = Partial<Omit<LeadData, 'id'>>;

// â”€â”€â”€ UTILS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function getLeadById(id: string) {
  const res = await client.execute('SELECT * FROM leads WHERE id = ?', [id]);
  return res.rows[0] || null;
}

// â”€â”€â”€ READ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export async function getLeads(filters: LeadFilters = {}, userId: string) {
  await assertPermission(userId, 'READ');

  const allowedKeys = ['nombre', 'email', 'estado_id'] as const;
  const safeFilters = {} as Record<string, any>;
  const values: any[] = [];

  for (const key of allowedKeys) {
    if (key in filters && filters[key] !== undefined) {
      safeFilters[key] = filters[key];
      values.push(filters[key]);
    }
  }

  let query = 'SELECT * FROM leads';
  if (Object.keys(safeFilters).length > 0) {
    const conditions = Object.keys(safeFilters).map(() => '?? = ?').join(' AND ');
    query += ` WHERE ${conditions}`;
  }

  // Nota: Turso/libSQL usa ?? para identificadores seguros
  const result = await client.execute(query, [...Object.keys(safeFilters), ...values]);
  return result.rows;
}

// â”€â”€â”€ CREATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export async function createLead(data: LeadData, userId: string, ip?: string, userAgent?: string) {
  await assertPermission(userId, 'CREATE');

  if (!data.nombre) throw new Error('El nombre es obligatorio.');
  if (!data.estado_id) throw new Error('El estado es obligatorio.');

  const existing = await getLeadById(data.id);
  if (existing) throw new Error('Ya existe un lead con este ID.');

  await client.execute(
    `INSERT INTO leads (id, nombre, email, telefono, estado_id) VALUES (?, ?, ?, ?, ?)`,
    [data.id, data.nombre, data.email ?? null, data.telefono ?? null, data.estado_id]
  );

  await auditLog('CREAR', {
    user_id: userId,
    ip_address: ip,
    user_agent: userAgent,
    table: 'leads',
    record_id: data.id,
    new_value: data
  });

  return { id: data.id };
}

// â”€â”€â”€ UPDATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export async function updateLead(id: string, data: LeadUpdateData, userId: string, ip?: string, userAgent?: string) {
  if (!id) throw new Error('ID obligatorio.');
  await assertPermission(userId, 'UPDATE');

  const oldLead = await getLeadById(id);
  if (!oldLead) throw new Error('Lead no encontrado.');

  const fields: string[] = [];
  const values: any[] = [];

  (['nombre', 'email', 'telefono', 'estado_id'] as const).forEach(key => {
    if (key in data) {
      fields.push(`?? = ?`);
      values.push(key, data[key] ?? null);
    }
  });

  if (fields.length === 0) return { id };

  const query = `UPDATE leads SET ${fields.join(', ')} WHERE id = ?`;
  await client.execute(query, [...values, id]);

  await auditLog('ACTUALIZAR', {
    user_id: userId,
    ip_address: ip,
    user_agent: userAgent,
    table: 'leads',
    record_id: id,
    old_value: oldLead,
    new_value: { ...oldLead, ...data }
  });

  return { id };
}

// â”€â”€â”€ DELETE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export async function deleteLead(id: string, userId: string, ip?: string, userAgent?: string) {
  if (!id) throw new Error('ID obligatorio.');
  await assertPermission(userId, 'DELETE');

  const lead = await getLeadById(id);
  if (!lead) throw new Error('Lead no encontrado.');

  await client.execute('DELETE FROM leads WHERE id = ?', [id]);

  await auditLog('ELIMINAR', {
    user_id: userId,
    ip_address: ip,
    user_agent: userAgent,
    table: 'leads',
    record_id: id,
    old_value: lead
  });

  return { id };
}
```

> ğŸ”’ **Nota**: Usamos `??` para columnas en lugar de interpolaciÃ³n directa â†’ esto lo hace **seguro contra inyecciÃ³n** en libSQL/Turso.

---

### 4. âœ… Endpoints API

#### `server/api/leads/index.get.ts`

```ts
import { getLeads } from '../../services/leads';
import { getAuthUserId } from '../../utils/auth'; // tÃº debes implementar esto

export default defineEventHandler(async (event) => {
  const userId = await getAuthUserId(event); // â† tÃº defines cÃ³mo obtener el userId
  const filters = getQuery(event);
  return await getLeads(filters as any, userId);
});
```

#### `server/api/leads/index.post.ts`

```ts
import { createLead } from '../../services/leads';
import { getAuthUserId } from '../../utils/auth';

export default defineEventHandler(async (event) => {
  const userId = await getAuthUserId(event);
  const body = await readBody(event);
  const ip = event.node.req.headers['x-forwarded-for'] || event.node.req.socket.remoteAddress;
  const userAgent = event.node.req.headers['user-agent'];

  return await createLead(body, userId, ip as string, userAgent);
});
```

#### `server/api/leads/[id].patch.ts`

```ts
import { updateLead } from '../../services/leads';
import { getAuthUserId } from '../../utils/auth';

export default defineEventHandler(async (event) => {
  const userId = await getAuthUserId(event);
  const id = getRouterParam(event, 'id');
  const body = await readBody(event);
  const ip = event.node.req.headers['x-forwarded-for'] || event.node.req.socket.remoteAddress;
  const userAgent = event.node.req.headers['user-agent'];

  return await updateLead(id!, body, userId, ip as string, userAgent);
});
```

#### `server/api/leads/[id].delete.ts`

```ts
import { deleteLead } from '../../services/leads';
import { getAuthUserId } from '../../utils/auth';

export default defineEventHandler(async (event) => {
  const userId = await getAuthUserId(event);
  const id = getRouterParam(event, 'id');
  const ip = event.node.req.headers['x-forwarded-for'] || event.node.req.socket.remoteAddress;
  const userAgent = event.node.req.headers['user-agent'];

  return await deleteLead(id!, userId, ip as string, userAgent);
});
```

---

### 5. ğŸ›¡ï¸ Implementa `getAuthUserId`

Crea **`server/utils/auth.ts`** (ejemplo bÃ¡sico con cookie):

```ts
export async function getAuthUserId(event: any): Promise<string> {
  const userId = getCookie(event, 'user_id');
  if (!userId) throw createError({ statusCode: 401, message: 'No autenticado' });
  return userId;
}
```

> Ajusta esto a tu sistema de auth real (JWT, session, etc.).

---

### âœ… Resultado

- Toda la lÃ³gica sensible estÃ¡ en `server/services/` â†’ **nunca se expone al cliente**.
- Los endpoints son delgados y seguros.
- Los permisos y filtros estÃ¡n validados.
- El SQL es seguro contra inyecciÃ³n.
- Puedes crear un composable **cliente** que solo haga `$fetch` a estos endpoints.

Â¿Quieres que te genere tambiÃ©n el composable cliente para usar en tus componentes?